bfs_dfs

def dfs(visited, graph, node):
  """Performs Depth-First Search (DFS) traversal."""
  if node not in visited:
    print(node, end=" ")
    visited.add(node)
    for neighbour in graph[node]:
      dfs(visited, graph, neighbour)

def dfs_non_recursive(visited, graph, node):
  """Performs Depth-First Search (DFS) traversal using a stack."""
  stack = []
  stack.append(node)
  visited.add(node)

  while stack:
    s = stack.pop()
    print(s, end=" ")

    for neighbour in graph[s]:
      if neighbour not in visited:
        visited.add(neighbour)
        stack.append(neighbour)


def bfs(visited, graph, node, queue):
  """Performs Breadth-First Search (BFS) traversal using a queue."""
  visited.add(node)
  queue.append(node)

  while queue:
    s = queue.pop(0)
    print(s, end=" ")

    for neighbour in graph[s]:
      if neighbour not in visited:
        visited.add(neighbour)
        queue.append(neighbour)

def main():
  visited1 = set()  # To keep track of DFS visited nodes
  visited2 = set()  # To keep track of BFS visited nodes
  queue = []        # For BFS

  n = int(input("Enter number of nodes: "))
  graph = dict()

  for i in range(0, n):
    edges = int(input("Enter number of edges for node {}: ".format(i)))
    graph[i] = list()
    for j in range(0, edges):
      node = int(input("Enter edge {} for node {}: ".format(j, i)))
      graph[i].append(node)

  print("The following is DFS")
  dfs_non_recursive(visited1, graph, 2)  # Use the existing dfs function
  print()
  print("The following is BFS")
  bfs(visited2, graph, 0, queue)

if __name__ == '__main__':
  main()


# class Graph:
#     def __init__(self,n:int) -> None:
#         self.n = n
#         self.mat = [[0 for i in range(n)] for i in range(n)]

#     def add_edge(self,start,end):
#         self.mat[start][end] = 1
#         self.mat[end][start] = 1
    
#     def get_mat(self):
#         return self.mat
    
#     def disp_mat(self):
#         print("Adjacency Matrix is As Follows")
#         for row in self.mat:
#             print(row)
        
#     def display_dfs(self,start=0):
#         self.visited = [0 for i in range(self.n)]
#         print(f"The DFS Traversal Of Graph Starting Form {start} is :")
#         self.dfs(start)
#         print()
#         self.visited = [0 for i in range(self.n)]

#     def display_bfs(self,start=0):
#         self.visited = [0 for i in range(self.n)]
#         self.queue = [start]
#         print(f"The BFS Traversal Of Graph Starting Form {start} is :")
#         self.bfs()
#         print()
#         self.visited = [0 for i in range(self.n)]

#     def dfs(self,cur):
#         print(cur,end=" ")
#         self.visited[cur] = 1
#         for i in range(self.n):
#             if ((self.mat[cur][i]) and (not self.visited[i])):
#                 self.dfs(i)
    
#     def bfs(self):
#         if len(self.queue) == 0:
#             return None
#         cur = self.queue[0]
#         self.queue.pop(0)
#         print(cur,end=" ")
#         self.visited[cur] = 1
#         for i in range(self.n):
#             if ((self.mat[cur][i]) and (not self.visited[i])):
#                 self.queue.append(i)
#         self.bfs()

# def main():
#     n = int(input("Enter Number of Nodes:"))
#     e = int(input("Enter Number Of Edges:"))

#     g = Graph(n)
#     for i in range(e):
#         start = int(input(f"Enter start of Edge {i+1}:"))
#         end = int(input(f"Enter end of Edge {i+1}:"))
#         g.add_edge(start,end)
    
#     while True:
#         start = int(input("Enter start node of BFS:"))
#         g.display_bfs(start)
#         g.disp_mat()
#         start = int(input("Enter start node of DFS:"))
#         g.display_dfs(start)
#         g.disp_mat()
        
# if __name__ == "__main__":
#     main()


# # """
# # sample input 1

# # 4
# # 6
# # 0
# # 1
# # 0
# # 2
# # 1
# # 2
# # 2
# # 0
# # 2
# # 3
# # 3
# # 3

# # sample input 2

# # 7
# # 6
# # 0
# # 1
# # 0
# # 2
# # 1
# # 3
# # 1
# # 4
# # 4
# # 5
# # 4
# # 6


a_star

def print_state(title,state,h,g=0):
    print(title)
    for row in state:
        for elmt in row:
            print(elmt,end=" ")
        print()
    print(f"g={g}, h={h}, f={g+h}\n")

class Node:
    def __init__(self,data,level,fval):
        self.data = data
        self.level = level
        self.fval = fval

    def generate_child(self):
        x,y = self.find(self.data,'_')
        val_list = [[x,y-1],[x,y+1],[x-1,y],[x+1,y]]
        children = []
        for i in val_list:
            child = self.shuffle(self.data,x,y,i[0],i[1])
            if child is not None:
                child_node = Node(child,self.level+1,0)
                children.append(child_node)
        return children
        
    def shuffle(self,puz,x1,y1,x2,y2):
        if x2 >= 0 and x2 < len(self.data) and y2 >= 0 and y2 < len(self.data):
            temp_puz = []
            temp_puz = self.copy(puz)
            temp = temp_puz[x2][y2]
            temp_puz[x2][y2] = temp_puz[x1][y1]
            temp_puz[x1][y1] = temp
            return temp_puz
        else:
            return None
            

    def copy(self,root):
        temp = []
        for i in root:
            t = []
            for j in i:
                t.append(j)
            temp.append(t)
        return temp    
            
    def find(self,puz,x):
        for i in range(0,len(self.data)):
            for j in range(0,len(self.data)):
                if puz[i][j] == x:
                    return i,j


class Puzzle:
    def __init__(self,size):
        self.n = size
        self.open = []
        self.closed = []

    def accept(self):
        puz = []
        for i in range(0,self.n):
            temp = input().split(" ")
            puz.append(temp)
        return puz

    def f(self,start,goal):
        return self.h(start.data,goal)+start.level

    def h(self,start,goal):
        temp = 0
        for i in range(0,self.n):
            for j in range(0,self.n):
                if start[i][j] != goal[i][j] and start[i][j] != '_':
                    temp += 1
        return temp
        

    def process(self):
        print("Enter the start state matrix \n")
        start = self.accept()
        print("Enter the goal state matrix \n")        
        goal = self.accept()

        start = Node(start,0,0)
        start.fval = self.f(start,goal)
        """ Put the start node in the open list"""
        self.open.append(start)
        print("\n\n")
        while True:
            cur = self.open[0]
            
            if(self.h(cur.data,goal) == 0):
                print_state("Reached Goal State",cur.data,cur.fval - cur.level,cur.level)
                break
            print_state("State",cur.data,cur.fval - cur.level,cur.level)
            for i in cur.generate_child():
                i.fval = self.f(i,goal)
                self.open.append(i)
            self.closed.append(cur)
            del self.open[0]

            """ sort the opne list based on f value """
            self.open.sort(key = lambda x:x.fval,reverse=False)


puz = Puzzle(3)
puz.process()

"""
1 2 3
8 _ 4
7 6 5
2 8 1
_ 4 3
7 6 5

"""

prims,selection

def print_list(arr):
    print(' '.join(str(i) for i in arr))

def print_2D(arr):
    for row in arr:
        print(' '.join(str(i) for i in row))
    print()

def selection_sort(lst):
    for i in range(len(lst)):
        t = i
        for j in range(i+1, len(lst)):
            if lst[t] > lst[j]:
                t = j
        lst[i], lst[t] = lst[t], lst[i]
    return lst

def prims_algorithm():
    n = int(input("Enter Number of Nodes: "))
    mat = [[0]*n for _ in range(n)]
    m = int(input("Enter Number of Edges: "))
    for i in range(m):
        print(f"Enter Details of Edge {i+1} as start end weight")
        start, end, weight = map(int, input().split())
        mat[start][end] = weight
        mat[end][start] = weight
    print_2D(mat)
    vis = [0]*n
    tree = [[0]*3 for _ in range(n-1)]
    sumw = 0
    for i in range(n):
        if vis[i] == 1:
            sv, ev, wv = 0, 0, 999
            flag = False
            for j in range(n):
                if mat[i][j] > 0 and mat[i][j] < wv and vis[j] != 1:
                    wv = mat[i][j]
                    sv = i
                    ev = j
                    flag = True
            if flag:
                vis[ev] = 1
                tree[sumw][0] = sv
                tree[sumw][1] = ev
                tree[sumw][2] = wv
                sumw += 1
            else:
                break
    print("Tree is :")
    print_2D(tree)

while True:
    print("--MENU--")
    print("1. Selection Sort")
    print("2. Prim's Minimum Spanning Tree Algorithm")
    print("9. exit")
    ch = int(input("Enter Your Choice(0 to Display Menu): "))
    if ch == 1:
        n = int(input("Enter Number of Elements: "))
        lst = list(map(int, input("Enter Numbers: ").split()))
        print("Original List ", end='')
        print_list(lst)
        new_lst = selection_sort(lst)
        print("List After Selection Sort ", end='')
        print_list(new_lst)
    elif ch == 2:
        prims_algorithm()
    elif ch == 9:
        print("Thank You")
        break
    else:
        print("Invalid Input")


n_queen

# N-Queens Problem
ans = [[]]
def printBoard(arr):
    for a in arr:
        for b in a:
            if(b): print('Q', end=" ")
            else: print('.',end=" ")
        print()

def copy(board,n):
    global ans
    for i in range(n):
        for j in range(n):
            ans[i][j] = board[i][j]

def isSafe(board,x,y,n):
    # in row
    j = 0
    while(j<n):
        if(board[x][j] == 1):
            return False
        j+=1

    # col above
    i = x-1
    while(i>=0):
        if(board[i][y] == 1):
            return False
        i-=1
        
    # diagonal top left
    i = x-1
    j = y-1
    while(i>=0 and j >= 0):
        if(board[i][j] == 1):
            return False
        i-=1
        j-=1

    # diagonal top right
    i = x-1
    j = y+1
    while(i>=0 and j < n):
        if(board[i][j] == 1):
            return False
        i-=1
        j+=1

    return True

def solve(row,  board, n,j=0):
    if row >= n:
        if(j==n-1):
            print("Solution:")
            printBoard(board)
            print("\n")
        copy(board, n)
        return

    for j in range(n):  # Iterate over columns only
        if isSafe(board, row, j, n):
            # put queen
            board[row][j] = 1
            # solve
            solve(row + 1,  board, n,j)
            # backtrack
            board[row][j] = 0

def main(n):
    global ans
    board = [[0 for i in range(n)] for i in range(n)]
    ans = [[0 for i in range(n)] for i in range(n)]

    solve(0,board,n)

    print("Final Solution Is:")
    printBoard(ans)

if __name__ == "__main__":
    n = int(input("Enter the value of n: "))
    main(n)


chatbot

class SimpleChatBot:
    def __init__(self):
        self.responses = {
            "hello": "Hello! How can I assist you today?",
            "how are you": "I'm a bot, so I don't have feelings, but I'm here to help you. How can I assist you?",
            "what can you do": "I can provide information and answer questions to the best of my ability.",
            "goodbye": "Goodbye! Have a great day!"
        }

    def get_response(self, user_input):
        user_input = user_input.lower()
        if user_input in self.responses:
            return self.responses[user_input]
        else:
            return "I'm sorry, I didn't understand that. Could you please rephrase?"

chatbot = SimpleChatBot()
while True:
    user_input = input("User: ")
    if user_input.lower() == "exit":
        break
    response = chatbot.get_response(user_input)
    print("Bot: ", response)


chatbot_nltk

import nltk
from nltk.chat.util import Chat, reflections

pairs = [
    [
        r"my name is (.*)",
        ["Hello %1, How are you today ?",],
    ],
    [
        r"hi|hey|hello",
        ["Hello", "Hey there",],
    ],
    [
        r"quit",
        ["Bye take care. See you soon :) ", "It was nice talking to you. See you soon :)"],
    ],
]

def chatbot():
    print("Hi, I'm the chatbot you built")

    chat = Chat(pairs, reflections)
    chat.converse()

if __name__ == "__main__":
    chatbot()



health_expert_system

def select_diseases(symptoms):
    diseases = {
        "Allergies": ['sneezing', 'blocked nose', 'watery eyes', 'red eyes', 'coughing', 'red rash'],
        "Asthma": ['wheezing', 'shortness of breath', 'tight chest'],
        "Head Tumor": ['severe headaches', 'seizures', 'mental changes', 'vision problem'],
        "Chronic Pain": ['diabetes', 'arthritis', 'back pain'],
        "Dehydration": ['feeling thirsty', 'dry mouth', 'tiredness', 'strong smelling urine'],
        "Food Poisoning": ['nausea', 'vomiting', 'weakness', 'loss of appetite', 'aching muscles', 'chills','sneezing']
    }

    # Convert all disease symptoms to lower case for case insensitive matching
    diseases = {disease: [symptom.lower() for symptom in symptoms_list] for disease, symptoms_list in diseases.items()}

    matching_diseases = []
    
    for disease, disease_symptoms in diseases.items():
        if any(symptom in disease_symptoms for symptom in symptoms):
            matching_diseases.append(disease)

    return matching_diseases


# Prompt the user to enter symptoms
symptoms_input = input("Enter your symptoms (separated by commas): ")

# Check if user entered any symptoms
if not symptoms_input.strip():
    print("No symptoms were entered. Please try again.")
else:
    # Convert symptoms to lower case and remove leading/trailing spaces
    symptoms = [symptom.strip().lower() for symptom in symptoms_input.split(',')]

    # Select the diseases based on symptoms
    diagnosed_diseases = select_diseases(symptoms)

    # Print the diagnosed diseases or an error message if no match found
    if diagnosed_diseases:
        print("You may have the following disease(s):")
        for disease in diagnosed_diseases:
            print("- " + disease)
    else:
        print("Unable to diagnose any disease based on the given symptoms.")

