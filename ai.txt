bfs_dfs

class Node:
    def __init__(self, num):
        self.data = num
        self.left = None
        self.right = None

head=None

def depthFirstSearch(root):
    if root is not None:
        print(root.data)
        depthFirstSearch(root.left)
        depthFirstSearch(root.right)

def breadthFirstSearch(root):
    if root is None:
        return

    queue = [root]
    while queue:
        current = queue.pop(0)
        print(current.data)

        if current.left is not None:
            queue.append(current.left)
        if current.right is not None:
            queue.append(current.right)


def insertnode(num):
    global head
    if head is None:
        head = Node(num)
    else:
        current = head
        while True:
            if num < current.data:
                if current.left is None:
                    current.left = Node(num)
                    break
                else:
                    current = current.left
            else:
                if current.right is None:
                    current.right = Node(num)
                    break
                else:
                    current = current.right


for i in range(7):
    num = int(input("Enter number:"))
    insertnode(num)

print(head.data)

print("Depth-First Search:")
depthFirstSearch(head)

print("\nBreadth-First Search:")
breadthFirstSearch(head)


# #Non Recursive
# def dfs(graph, start):
#   """
#   Performs Depth-First Search on a graph (adjacency list) and returns 
#   a list containing the visited nodes in DFS order.

#   Args:
#       graph: A dictionary where keys are nodes and values are lists of neighbors.
#       start: The starting node for the traversal.
#   """
#   visited = set()  # Keeps track of visited nodes
#   stack = [start]  # Use a stack for DFS (LIFO)

#   while stack:
#     current = stack.pop()  # Get the last element from the stack (LIFO)
#     if current not in visited:
#       visited.add(current)  # Mark current node as visited
#       stack.extend(graph[current])  # Add neighbors to the stack for DFS exploration

#   return visited

# def bfs(graph, start):
#   """
#   Performs Breadth-First Search on a graph (adjacency list) and returns 
#   a list containing the visited nodes in BFS order.

#   Args:
#       graph: A dictionary where keys are nodes and values are lists of neighbors.
#       start: The starting node for the traversal.
#   """
#   visited = set()  # Keeps track of visited nodes
#   queue = [start]  # Use a queue for BFS (FIFO)

#   while queue:
#     current = queue.pop(0)  # Get the first element from the queue (FIFO)
#     if current not in visited:
#       visited.add(current)  # Mark current node as visited
#       queue.extend(graph[current])  # Add neighbors to the queue for BFS exploration

#   return visited
# # Example usage
# graph = {
#   'A': ['B', 'C'],
#   'B': ['D', 'E'],
#   'C': ['F'],
#   'D': [],
#   'E': [],
#   'F': []
# }

# dfs_visited = dfs(graph, 'A')
# print("DFS Visited:", dfs_visited)  # Output: {'A', 'C', 'F', 'B', 'D', 'E'} (Order may vary)

# bfs_visited = bfs(graph, 'A')
# print("BFS Visited:", bfs_visited)  # Output: {'A', 'B', 'C', 'D', 'E', 'F'}


a_star

def print_state(title,state,h,g=0):
    print(title)
    for row in state:
        for elmt in row:
            print(elmt,end=" ")
        print()
    print(f"g={g}, h={h}, f={g+h}\n")

class Node:
    def __init__(self,data,level,fval):
        self.data = data
        self.level = level
        self.fval = fval

    def generate_child(self):
        x,y = self.find(self.data,'_')
        val_list = [[x,y-1],[x,y+1],[x-1,y],[x+1,y]]
        children = []
        for i in val_list:
            child = self.shuffle(self.data,x,y,i[0],i[1])
            if child is not None:
                child_node = Node(child,self.level+1,0)
                children.append(child_node)
        return children
        
    def shuffle(self,puz,x1,y1,x2,y2):
        if x2 >= 0 and x2 < len(self.data) and y2 >= 0 and y2 < len(self.data):
            temp_puz = []
            temp_puz = self.copy(puz)
            temp = temp_puz[x2][y2]
            temp_puz[x2][y2] = temp_puz[x1][y1]
            temp_puz[x1][y1] = temp
            return temp_puz
        else:
            return None
            

    def copy(self,root):
        temp = []
        for i in root:
            t = []
            for j in i:
                t.append(j)
            temp.append(t)
        return temp    
            
    def find(self,puz,x):
        for i in range(0,len(self.data)):
            for j in range(0,len(self.data)):
                if puz[i][j] == x:
                    return i,j


class Puzzle:
    def __init__(self,size):
        self.n = size
        self.open = []
        self.closed = []

    def accept(self):
        puz = []
        for i in range(0,self.n):
            temp = input().split(" ")
            puz.append(temp)
        return puz

    def f(self,start,goal):
        return self.h(start.data,goal)+start.level

    def h(self,start,goal):
        temp = 0
        for i in range(0,self.n):
            for j in range(0,self.n):
                if start[i][j] != goal[i][j] and start[i][j] != '_':
                    temp += 1
        return temp
        

    def process(self):
        print("Enter the start state matrix \n")
        start = self.accept()
        print("Enter the goal state matrix \n")        
        goal = self.accept()

        start = Node(start,0,0)
        start.fval = self.f(start,goal)
        """ Put the start node in the open list"""
        self.open.append(start)
        print("\n\n")
        while True:
            cur = self.open[0]
            
            if(self.h(cur.data,goal) == 0):
                print_state("Reached Goal State",cur.data,cur.fval - cur.level,cur.level)
                break
            print_state("State",cur.data,cur.fval - cur.level,cur.level)
            for i in cur.generate_child():
                i.fval = self.f(i,goal)
                self.open.append(i)
            self.closed.append(cur)
            del self.open[0]

            """ sort the opne list based on f value """
            self.open.sort(key = lambda x:x.fval,reverse=False)


puz = Puzzle(3)
puz.process()

"""
1 2 3
8 _ 4
7 6 5
2 8 1
_ 4 3
7 6 5

"""

prims,selection

def print_list(arr):
    print(' '.join(str(i) for i in arr))

def print_2D(arr):
    for row in arr:
        print(' '.join(str(i) for i in row))
    print()

def selection_sort(lst):
    for i in range(len(lst)):
        t = i
        for j in range(i+1, len(lst)):
            if lst[t] > lst[j]:
                t = j
        lst[i], lst[t] = lst[t], lst[i]
    return lst

def prims_algorithm():
    n = int(input("Enter Number of Nodes: "))
    mat = [[0]*n for _ in range(n)]
    m = int(input("Enter Number of Edges: "))
    for i in range(m):
        print(f"Enter Details of Edge {i+1} as start end weight")
        start, end, weight = map(int, input().split())
        mat[start][end] = weight
        mat[end][start] = weight
    print_2D(mat)
    vis = [0]*n
    tree = [[0]*3 for _ in range(n-1)]
    sumw = 0
    for i in range(n):
        if vis[i] == 1:
            sv, ev, wv = 0, 0, 999
            flag = False
            for j in range(n):
                if mat[i][j] > 0 and mat[i][j] < wv and vis[j] != 1:
                    wv = mat[i][j]
                    sv = i
                    ev = j
                    flag = True
            if flag:
                vis[ev] = 1
                tree[sumw][0] = sv
                tree[sumw][1] = ev
                tree[sumw][2] = wv
                sumw += 1
            else:
                break
    print("Tree is :")
    print_2D(tree)

while True:
    print("--MENU--")
    print("1. Selection Sort")
    print("2. Prim's Minimum Spanning Tree Algorithm")
    print("9. exit")
    ch = int(input("Enter Your Choice(0 to Display Menu): "))
    if ch == 1:
        n = int(input("Enter Number of Elements: "))
        lst = list(map(int, input("Enter Numbers: ").split()))
        print("Original List ", end='')
        print_list(lst)
        new_lst = selection_sort(lst)
        print("List After Selection Sort ", end='')
        print_list(new_lst)
    elif ch == 2:
        prims_algorithm()
    elif ch == 9:
        print("Thank You")
        break
    else:
        print("Invalid Input")


n_queen

# N-Queens Problem
ans = [[]]
def printBoard(arr):
    for a in arr:
        for b in a:
            if(b): print('Q', end=" ")
            else: print('.',end=" ")
        print()

def copy(board,n):
    global ans
    for i in range(n):
        for j in range(n):
            ans[i][j] = board[i][j]

def isSafe(board,x,y,n):
    # in row
    j = 0
    while(j<n):
        if(board[x][j] == 1):
            return False
        j+=1

    # col above
    i = x-1
    while(i>=0):
        if(board[i][y] == 1):
            return False
        i-=1
        
    # diagonal top left
    i = x-1
    j = y-1
    while(i>=0 and j >= 0):
        if(board[i][j] == 1):
            return False
        i-=1
        j-=1

    # diagonal top right
    i = x-1
    j = y+1
    while(i>=0 and j < n):
        if(board[i][j] == 1):
            return False
        i-=1
        j+=1

    return True

def solve(row,  board, n,j=0):
    if row >= n:
        if(j==n-1):
            print("Solution:")
            printBoard(board)
            print("\n")
        copy(board, n)
        return

    for j in range(n):  # Iterate over columns only
        if isSafe(board, row, j, n):
            # put queen
            board[row][j] = 1
            # solve
            solve(row + 1,  board, n,j)
            # backtrack
            board[row][j] = 0

def main(n):
    global ans
    board = [[0 for i in range(n)] for i in range(n)]
    ans = [[0 for i in range(n)] for i in range(n)]

    solve(0,board,n)

    print("Final Solution Is:")
    printBoard(ans)

if __name__ == "__main__":
    n = int(input("Enter the value of n: "))
    main(n)


chatbot

class SimpleChatBot:
    def __init__(self):
        self.responses = {
            "hello": "Hello! How can I assist you today?",
            "how are you": "I'm a bot, so I don't have feelings, but I'm here to help you. How can I assist you?",
            "what can you do": "I can provide information and answer questions to the best of my ability.",
            "goodbye": "Goodbye! Have a great day!"
        }

    def get_response(self, user_input):
        user_input = user_input.lower()
        if user_input in self.responses:
            return self.responses[user_input]
        else:
            return "I'm sorry, I didn't understand that. Could you please rephrase?"

chatbot = SimpleChatBot()
while True:
    user_input = input("User: ")
    if user_input.lower() == "exit":
        break
    response = chatbot.get_response(user_input)
    print("Bot: ", response)


chatbot_nltk

import nltk
from nltk.chat.util import Chat, reflections

pairs = [
    [
        r"my name is (.*)",
        ["Hello %1, How are you today ?",],
    ],
    [
        r"hi|hey|hello",
        ["Hello", "Hey there",],
    ],
    [
        r"quit",
        ["Bye take care. See you soon :) ", "It was nice talking to you. See you soon :)"],
    ],
]

def chatbot():
    print("Hi, I'm the chatbot you built")

    chat = Chat(pairs, reflections)
    chat.converse()

if __name__ == "__main__":
    chatbot()



health_expert_system

def select_diseases(symptoms):
    diseases = {
        "Allergies": ['sneezing', 'blocked nose', 'watery eyes', 'red eyes', 'coughing', 'red rash'],
        "Asthma": ['wheezing', 'shortness of breath', 'tight chest'],
        "Head Tumor": ['severe headaches', 'seizures', 'mental changes', 'vision problem'],
        "Chronic Pain": ['diabetes', 'arthritis', 'back pain'],
        "Dehydration": ['feeling thirsty', 'dry mouth', 'tiredness', 'strong smelling urine'],
        "Food Poisoning": ['nausea', 'vomiting', 'weakness', 'loss of appetite', 'aching muscles', 'chills','sneezing']
    }

    # Convert all disease symptoms to lower case for case insensitive matching
    diseases = {disease: [symptom.lower() for symptom in symptoms_list] for disease, symptoms_list in diseases.items()}

    matching_diseases = []
    
    for disease, disease_symptoms in diseases.items():
        if any(symptom in disease_symptoms for symptom in symptoms):
            matching_diseases.append(disease)

    return matching_diseases


# Prompt the user to enter symptoms
symptoms_input = input("Enter your symptoms (separated by commas): ")

# Check if user entered any symptoms
if not symptoms_input.strip():
    print("No symptoms were entered. Please try again.")
else:
    # Convert symptoms to lower case and remove leading/trailing spaces
    symptoms = [symptom.strip().lower() for symptom in symptoms_input.split(',')]

    # Select the diseases based on symptoms
    diagnosed_diseases = select_diseases(symptoms)

    # Print the diagnosed diseases or an error message if no match found
    if diagnosed_diseases:
        print("You may have the following disease(s):")
        for disease in diagnosed_diseases:
            print("- " + disease)
    else:
        print("Unable to diagnose any disease based on the given symptoms.")

